from machine import SoftSPI, Pin  # Replace with your SPI library
import time

def crc15( data: bytes,length: int = 2) -> int:
    if length <= 0:
        raise ValueError("length must be > 0")
    if data is None:
        raise ValueError("data must not be None")

    # Pre-computed CRC15 Table for polynomial 0xC599
    crc15_table = [
        0x0000, 0x4599, 0x4EAB, 0x0B32, 0x58CF, 0x1D56, 0x1664, 0x53FD, 0x7407, 0x319E, 0x3AAC, 0x7F35,
        0x2CC8, 0x6951, 0x6263, 0x27FA, 0x2D97, 0x680E, 0x633C, 0x26A5, 0x7558, 0x30C1, 0x3BF3, 0x7E6A,
        0x5990, 0x1C09, 0x173B, 0x52A2, 0x015F, 0x44C6, 0x4FF4, 0x0A6D, 0x5B2E, 0x1EB7, 0x1585, 0x501C,
        0x03E1, 0x4678, 0x4D4A, 0x08D3, 0x2F29, 0x6AB0, 0x6182, 0x241B, 0x77E6, 0x327F, 0x394D, 0x7CD4,
        0x76B9, 0x3320, 0x3812, 0x7D8B, 0x2E76, 0x6BEF, 0x60DD, 0x2544, 0x02BE, 0x4727, 0x4C15, 0x098C,
        0x5A71, 0x1FE8, 0x14DA, 0x5143, 0x73C5, 0x365C, 0x3D6E, 0x78F7, 0x2B0A, 0x6E93, 0x65A1, 0x2038,
        0x07C2, 0x425B, 0x4969, 0x0CF0, 0x5F0D, 0x1A94, 0x11A6, 0x543F, 0x5E52, 0x1BCB, 0x10F9, 0x5560,
        0x069D, 0x4304, 0x4836, 0x0DAF, 0x2A55, 0x6FCC, 0x64FE, 0x2167, 0x729A, 0x3703, 0x3C31, 0x79A8,
        0x28EB, 0x6D72, 0x6640, 0x23D9, 0x7024, 0x35BD, 0x3E8F, 0x7B16, 0x5CEC, 0x1975, 0x1247, 0x57DE,
        0x0423, 0x41BA, 0x4A88, 0x0F11, 0x057C, 0x40E5, 0x4BD7, 0x0E4E, 0x5DB3, 0x182A, 0x1318, 0x5681,
        0x717B, 0x34E2, 0x3FD0, 0x7A49, 0x29B4, 0x6C2D, 0x671F, 0x2286, 0x2213, 0x678A, 0x6CB8, 0x2921,
        0x7ADC, 0x3F45, 0x3477, 0x71EE, 0x5614, 0x138D, 0x18BF, 0x5D26, 0x0EDB, 0x4B42, 0x4070, 0x05E9,
        0x0F84, 0x4A1D, 0x412F, 0x04B6, 0x574B, 0x12D2, 0x19E0, 0x5C79, 0x7B83, 0x3E1A, 0x3528, 0x70B1,
        0x234C, 0x66D5, 0x6DE7, 0x287E, 0x793D, 0x3CA4, 0x3796, 0x720F, 0x21F2, 0x646B, 0x6F59, 0x2AC0,
        0x0D3A, 0x48A3, 0x4391, 0x0608, 0x55F5, 0x106C, 0x1B5E, 0x5EC7, 0x54AA, 0x1133, 0x1A01, 0x5F98,
        0x0C65, 0x49FC, 0x42CE, 0x0757, 0x20AD, 0x6534, 0x6E06, 0x2B9F, 0x7862, 0x3DFB, 0x36C9, 0x7350,
        0x51D6, 0x144F, 0x1F7D, 0x5AE4, 0x0919, 0x4C80, 0x47B2, 0x022B, 0x25D1, 0x6048, 0x6B7A, 0x2EE3,
        0x7D1E, 0x3887, 0x33B5, 0x762C, 0x7C41, 0x39D8, 0x32EA, 0x7773, 0x248E, 0x6117, 0x6A25, 0x2FBC,
        0x0846, 0x4DDF, 0x46ED, 0x0374, 0x5089, 0x1510, 0x1E22, 0x5BBB, 0x0AF8, 0x4F61, 0x4453, 0x01CA,
        0x5237, 0x17AE, 0x1C9C, 0x5905, 0x7EFF, 0x3B66, 0x3054, 0x75CD, 0x2630, 0x63A9, 0x689B, 0x2D02,
        0x276F, 0x62F6, 0x69C4, 0x2C5D, 0x7FA0, 0x3A39, 0x310B, 0x7492, 0x5368, 0x16F1, 0x1DC3, 0x585A,
        0x0BA7, 0x4E3E, 0x450C, 0x0095,
    ]

    pec = 0x10  # PEC15_SEED

    for byte in range(length):
        position = ((pec >> (15 - 8)) ^ data[byte]) & 0xFF
        pec = (pec << 8) ^ crc15_table[position]

    # Shift one bit to the left because in AFE, PEC is stored in 16 bit register with one trailing 0
    return ((pec & 0x7FFF) << 1)

def crc10(data: bytes, length: int = 6, receive = False) -> int:
    if length <= 0:
        raise ValueError("length must be > 0")
    if data is None:
        raise ValueError("data must not be None")
    crc10_table = [
        0x000, 0x08F, 0x11E, 0x191, 0x23C, 0x2B3, 0x322, 0x3AD, 0x0F7, 0x078, 0x1E9, 0x166, 0x2CB, 0x244,
        0x3D5, 0x35A, 0x1EE, 0x161, 0x0F0, 0x07F, 0x3D2, 0x35D, 0x2CC, 0x243, 0x119, 0x196, 0x007, 0x088,
        0x325, 0x3AA, 0x23B, 0x2B4, 0x3DC, 0x353, 0x2C2, 0x24D, 0x1E0, 0x16F, 0x0FE, 0x071, 0x32B, 0x3A4,
        0x235, 0x2BA, 0x117, 0x198, 0x009, 0x086, 0x232, 0x2BD, 0x32C, 0x3A3, 0x00E, 0x081, 0x110, 0x19F,
        0x2C5, 0x24A, 0x3DB, 0x354, 0x0F9, 0x076, 0x1E7, 0x168, 0x337, 0x3B8, 0x229, 0x2A6, 0x10B, 0x184,
        0x015, 0x09A, 0x3C0, 0x34F, 0x2DE, 0x251, 0x1FC, 0x173, 0x0E2, 0x06D, 0x2D9, 0x256, 0x3C7, 0x348,
        0x0E5, 0x06A, 0x1FB, 0x174, 0x22E, 0x2A1, 0x330, 0x3BF, 0x012, 0x09D, 0x10C, 0x183, 0x0EB, 0x064,
        0x1F5, 0x17A, 0x2D7, 0x258, 0x3C9, 0x346, 0x01C, 0x093, 0x102, 0x18D, 0x220, 0x2AF, 0x33E, 0x3B1,
        0x105, 0x18A, 0x01B, 0x094, 0x339, 0x3B6, 0x227, 0x2A8, 0x1F2, 0x17D, 0x0EC, 0x063, 0x3CE, 0x341,
        0x2D0, 0x25F, 0x2E1, 0x26E, 0x3FF, 0x370, 0x0DD, 0x052, 0x1C3, 0x14C, 0x216, 0x299, 0x308, 0x387,
        0x02A, 0x0A5, 0x134, 0x1BB, 0x30F, 0x380, 0x211, 0x29E, 0x133, 0x1BC, 0x02D, 0x0A2, 0x3F8, 0x377,
        0x2E6, 0x269, 0x1C4, 0x14B, 0x0DA, 0x055, 0x13D, 0x1B2, 0x023, 0x0AC, 0x301, 0x38E, 0x21F, 0x290,
        0x1CA, 0x145, 0x0D4, 0x05B, 0x3F6, 0x379, 0x2E8, 0x267, 0x0D3, 0x05C, 0x1CD, 0x142, 0x2EF, 0x260,
        0x3F1, 0x37E, 0x024, 0x0AB, 0x13A, 0x1B5, 0x218, 0x297, 0x306, 0x389, 0x1D6, 0x159, 0x0C8, 0x047,
        0x3EA, 0x365, 0x2F4, 0x27B, 0x121, 0x1AE, 0x03F, 0x0B0, 0x31D, 0x392, 0x203, 0x28C, 0x038, 0x0B7,
        0x126, 0x1A9, 0x204, 0x28B, 0x31A, 0x395, 0x0CF, 0x040, 0x1D1, 0x15E, 0x2F3, 0x27C, 0x3ED, 0x362,
        0x20A, 0x285, 0x314, 0x39B, 0x036, 0x0B9, 0x128, 0x1A7, 0x2FD, 0x272, 0x3E3, 0x36C, 0x0C1, 0x04E,
        0x1DF, 0x150, 0x3E4, 0x36B, 0x2FA, 0x275, 0x1D8, 0x157, 0x0C6, 0x049, 0x313, 0x39C, 0x20D, 0x282,
        0x12F, 0x1A0, 0x031, 0x0BE,
    ]
    pec = 0x10  # PEC10_SEED

    for byte in range(length):
        position = ((pec >> (10 - 8)) ^ data[byte]) & 0xFF
        pec = (pec << 8) ^ crc10_table[position]

    command_counter = 0
    if receive:
    # In receive data, compute CRC with the 6 received command counter bits
        command_counter = data[length] & 0xFC 

    pec ^= (command_counter << (10 - 8)) #polynom size - crc size
    for i in range(6): #command counter is 6 bits
        if (pec & 0x200) != 0: # test if bit 10 (MSB)is set
            pec = ((pec << 1) ^ 0x48F)  # Polynome is x48F
        else:
            pec = (pec << 1)
    return pec & 0x3FF

class HAL:
    def __init__(self, spi=None, cs_pin=16):
        """Initialize HAL with SPI interface and chip select pin."""
        self.spi = SoftSPI(baudrate=1000000, polarity=0, phase=0, sck=Pin(6), mosi=Pin(7), miso=Pin(15))
        self.spi.init(baudrate=1000000) # set the baudrate
        self.cs_pin = cs_pin  # Chip select pin
        self.cs = Pin(cs_pin, Pin.OUT)
        self.cs.value(1)  # CS high (inactive)

    def wakeup(self):
        self.cs.value(0)
        time.sleep_us(1)
        self.cs.value(1)
        time.sleep_us(10) #wati for 10 us until ok to communicate


    def read(self, address, length = 6) -> int:
        """Read 48-bit register at 16-bit address using SPI."""
        if address > 0xFFFF:
            raise ValueError(f"Address {address:04x} exceeds 16-bit max")
        self.cs.value(0)
        cmd0 = (address >> 8) & 0x07  # Upper 3 bits (assuming command format)
        cmd1 = address & 0xFF         # Lower 8 bits
        pec = crc15(bytes([cmd0, cmd1]), 2)
        pec0 = (pec >> 8) & 0xFF
        pec1 = pec & 0xFF
        self.spi.write(bytes([cmd0, cmd1, pec0, pec1]))
        buf = bytearray(length + 2)  # 6 data + 2 PEC
        self.spi.readinto(buf)
        self.cs.value(1)
        data = buf[0:length]
        data_crc = buf[0:length] + bytes([buf[length] & 0xFC])
        #print(f"Received data: {list(data)}")
        received_pec = ((buf[length] & 0x03) << 8) | buf[length + 1]
        calculated_pec = crc10(data_crc, receive=True)
        if received_pec != calculated_pec:
            print("PEC mismatch")
        value = int.from_bytes(data, "little")
        return value & 0xFFFFFFFFFFFF  # Ensure 48-bit

    def write(self, address, value):
        """Write 48-bit value to 16-bit address using SPI."""
        if address > 0xFFFF:
            raise ValueError(f"Address {address:04x} exceeds 16-bit max")
        if value > 0xFFFFFFFFFFFF:
            raise ValueError(f"Value {value:012x} exceeds 48-bit max")
        self.cs.value(0)
        cmd0 = (address >> 8) & 0x07  # Upper 3 bits (assuming command format)
        cmd1 = address & 0xFF         # Lower 8 bits
        data = (value & 0xFFFFFFFFFFFF).to_bytes(6, "little")  # 48-bit value
        pec = crc15(bytes([cmd0, cmd1]))  # CRC over command
        pec0 = (pec >> 8) & 0xFF
        pec1 = pec & 0xFF
        dpec = crc10(data)  # CRC over data
        dpec0 = (dpec >> 8) & 0xFF  
        dpec1 = dpec & 0xFF
        #print(f"write data: {list(data)}")
        self.spi.write(bytes([cmd0, cmd1]) + bytes([pec0, pec1])+ data + bytes([dpec0, dpec1]))
        self.cs.value(1)

    def command(self, command_code):
        """Send a command with 11-bit command code using SPI."""
        if command_code > 0x7FF:
            raise ValueError(f"Command code {command_code:03x} exceeds 11-bit max")
        self.cs.value(0)
        cmd0 = (command_code >> 8) & 0x07  # CC[10:8], bits 7-3 = 0
        cmd1 = command_code & 0xFF          # CC[7:0]
        pec = crc15(bytes([cmd0, cmd1]), 2)
        pec0 = (pec >> 8) & 0xFF
        pec1 = pec & 0xFF
        self.spi.write(bytes([cmd0, cmd1, pec0, pec1]))
        self.cs.value(1)